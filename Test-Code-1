#include <Wire.h>
#include <U8g2lib.h>

// ================== PIN MAP ==================
// --- Motor A pins (Left) ---
#define AIN1 32
#define AIN2 15
#define PWMA 14

// --- Motor B pins (Right) ---
#define BIN1 33
#define BIN2 27
#define PWMB 12

// --- Standby pin ---
#define STBY 13   // must be HIGH to enable TB6612

// --- Encoder pins (Left motor) ---
#define ENC_A_LEFT 34 // White -> A2
#define ENC_B_LEFT 5  // Yellow -> SCK

// --- Encoder pins (Right motor) ---
#define ENC_A_RIGHT 36 // White -> A4
#define ENC_B_RIGHT 39 // Yellow -> A3

// --- Button pin ---
#define BTN_PIN 26 // active-LOW

// --- 2x Digital Line Sensors ---
// If your board actually supports pins 7 & 8, change these to 7 and 8.
#define SENS_L 35      // left sensor (digital OUT from HW-870)
#define SENS_R 21      // right sensor (digital OUT from HW-870)

// --- OLED (U8g2) ---
#define SDA_PIN 22
#define SCL_PIN 20
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(
  U8G2_R0, /* reset=*/ U8X8_PIN_NONE, /* clock=*/ SCL_PIN, /* data=*/ SDA_PIN
);

// ================== MOTOR PWM (ESP32 LEDC) ==================
#define CH_A 0
#define CH_B 1
#define FREQ 20000   // 20 kHz keeps motors quiet
#define RES  8       // 8-bit (0..255)

// ================== MOTOR & ENCODER PARAMS ==================
#define GEAR_RATIO     20.4
#define ENCODER_TICKS  14

// --- Encoder variables ---
volatile unsigned long lastTimeLeft = 0, periodLeft = 0;
volatile bool dirLeft = true;
volatile unsigned long lastTimeRight = 0, periodRight = 0;
volatile bool dirRight = true;

// --- Button state ---
bool motorsOn = false;

// --- Line follow tuning ---
int basePWM = 120;     // forward speed (0..255)
int turnPWM = 160;     // speed for the faster wheel during a turn
int pivotPWM = 140;    // pivot in place if needed

// Interpret sensor logic: HIGH=BLACK, LOW=WHITE (per your test code)
inline bool isBlack(int pin) { return digitalRead(pin) == HIGH; }

// ================== ISRs ==================
void IRAM_ATTR handleLeftA() {
  unsigned long now = micros();
  if (lastTimeLeft > 0) periodLeft = now - lastTimeLeft;
  lastTimeLeft = now;
  dirLeft = digitalRead(ENC_B_LEFT); // quadrature phase
}
void IRAM_ATTR handleRightA() {
  unsigned long now = micros();
  if (lastTimeRight > 0) periodRight = now - lastTimeRight;
  lastTimeRight = now;
  dirRight = digitalRead(ENC_B_RIGHT);
}

// ================== MOTOR HELPERS ==================
void motorStandby(bool en) {
  digitalWrite(STBY, en ? HIGH : LOW);
}

void leftForward(int pwm) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  ledcWrite(CH_A, constrain(pwm, 0, 255));
}
void leftBrake() {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, LOW);
  ledcWrite(CH_A, 0);
}

void rightForward(int pwm) {
  // (Your original right forward = BIN2 HIGH, BIN1 LOW)
  digitalWrite(BIN1, LOW);
  digitalWrite(BIN2, HIGH);
  ledcWrite(CH_B, constrain(pwm, 0, 255));
}
void rightBrake() {
  digitalWrite(BIN1, LOW);
  digitalWrite(BIN2, LOW);
  ledcWrite(CH_B, 0);
}

void leftReverse(int pwm) {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, HIGH);
  ledcWrite(CH_A, constrain(pwm, 0, 255));
}
void rightReverse(int pwm) {
  digitalWrite(BIN1, HIGH);
  digitalWrite(BIN2, LOW);
  ledcWrite(CH_B, constrain(pwm, 0, 255));
}

void driveStop() {
  leftBrake();
  rightBrake();
}

// ================== SETUP ==================
void setup() {
  Serial.begin(115200);

  // Motor pins
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  motorStandby(true);

  // PWM channels
  ledcSetup(CH_A, FREQ, RES);
  ledcAttachPin(PWMA, CH_A);
  ledcSetup(CH_B, FREQ, RES);
  ledcAttachPin(PWMB, CH_B);

  // Encoders
  pinMode(ENC_A_LEFT, INPUT);
  pinMode(ENC_B_LEFT, INPUT);
  pinMode(ENC_A_RIGHT, INPUT);
  pinMode(ENC_B_RIGHT, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENC_A_LEFT), handleLeftA, RISING);
  attachInterrupt(digitalPinToInterrupt(ENC_A_RIGHT), handleRightA, RISING);

  // Button
  pinMode(BTN_PIN, INPUT_PULLUP);

  // Sensors
  pinMode(SENS_L, INPUT);
  pinMode(SENS_R, INPUT);

  // OLED
  Wire.begin(SDA_PIN, SCL_PIN, 100000);
  u8g2.begin();
  u8g2.setFont(u8g2_font_6x12_tr);

  Serial.println("Line Follower + Encoders + OLED + Button ready");
}

// ================== LOOP ==================
void loop() {
  // --- Button toggle motors ---
  static bool lastBtn = HIGH;
  bool btn = digitalRead(BTN_PIN);
  if (lastBtn == HIGH && btn == LOW) {
    motorsOn = !motorsOn;
    delay(200); // debounce
  }
  lastBtn = btn;

  // --- Read sensors ---
  bool L_black = isBlack(SENS_L);
  bool R_black = isBlack(SENS_R);

  // --- Line-follow decision table ---
  // Assumes BLACK line on WHITE floor, sensors read HIGH on BLACK.
  int leftCmd = 0, rightCmd = 0;
  String action = "STOP";

  if (motorsOn) {
    if (L_black && R_black) {
      // centered on wide line (or both see line) -> go straight a bit faster
      leftCmd = basePWM + 20;
      rightCmd = basePWM + 20;
      action = "STRAIGHT (both BLACK)";
    } else if (L_black && !R_black) {
      // line under left -> steer LEFT
      leftCmd  = basePWM - 40;       // slow left
      rightCmd = turnPWM;            // speed up right
      action = "TURN LEFT";
    } else if (!L_black && R_black) {
      // line under right -> steer RIGHT
      leftCmd  = turnPWM;            // speed up left
      rightCmd = basePWM - 40;       // slow right
      action = "TURN RIGHT";
    } else {
      // both WHITE -> lost line: pivot to search (pick a direction)
      leftCmd =  pivotPWM;
      rightCmd = 0;
      action = "SEARCH (pivot left)";
    }

    // Apply motor commands (forward by default)
    leftForward(leftCmd);
    rightForward(rightCmd);
  } else {
    driveStop();
    action = "MOTORS OFF";
  }

  // --- Calculate RPMs from encoder periods ---
  float rpmLeft = 0, rpmRight = 0;
  if (periodLeft > 0)
    rpmLeft = (1e6f / (float)periodLeft) * 60.0f / (ENCODER_TICKS * GEAR_RATIO);
  if (periodRight > 0)
    rpmRight = (1e6f / (float)periodRight) * 60.0f / (ENCODER_TICKS * GEAR_RATIO);

  // --- Serial ---
  Serial.print("L=");
  Serial.print(L_black ? "BLACK" : "WHITE");
  Serial.print("  R=");
  Serial.print(R_black ? "BLACK" : "WHITE");
  Serial.print("  | Cmd L/R = ");
  Serial.print(leftCmd);
  Serial.print("/");
  Serial.print(rightCmd);
  Serial.print("  | Left ");
  Serial.print(dirLeft ? "Fwd" : "Rev");
  Serial.print(" ");
  Serial.print(rpmLeft, 2);
  Serial.print(" RPM  || Right ");
  Serial.print(dirRight ? "Fwd" : "Rev");
  Serial.print(" ");
  Serial.print(rpmRight, 2);
  Serial.print(" RPM  || ");
  Serial.println(action);

  // --- OLED ---
  u8g2.clearBuffer();
  u8g2.setCursor(0, 12);
  u8g2.print(motorsOn ? "Motors: ON" : "Motors: OFF");

  u8g2.setCursor(0, 28);
  u8g2.print("L:");
  u8g2.print(L_black ? "BLACK" : "WHITE");
  u8g2.print("  R:");
  u8g2.print(R_black ? "BLACK" : "WHITE");

  u8g2.setCursor(0, 44);
  u8g2.print("RPM L/R: ");
  u8g2.print(rpmLeft, 0);
  u8g2.print("/");
  u8g2.print(rpmRight, 0);

  u8g2.setCursor(0, 60);
  u8g2.print(action);
  u8g2.sendBuffer();

  delay(40);
}
