#include <Wire.h>  

#include <U8g2lib.h>  

#include <math.h>  

 

// ---------- OLED ----------  

#define SDA_PIN 22  

#define SCL_PIN 20  

U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE, SCL_PIN, SDA_PIN);  

 

// ---------- TB6612 ----------  

#define AIN1 32  

#define AIN2 15  

#define PWMA 14  

#define BIN1 33  

#define BIN2 27  

#define PWMB 12  

#define STBY 13  

 

// ---------- Encoders ----------  

#define ENC_A_LEFT 34  

#define ENC_B_LEFT 5  

#define ENC_A_RIGHT 36  

#define ENC_B_RIGHT 39  

 

// ---------- Sensors ----------  

#define S_FL 21  

#define S_ML 4  

#define S_MR 25  

#define S_FR 19  

 

// ---------- Button ----------  

#define BTN_PIN 26  

 

// ---------- MPU6050 ----------  

#define MPU_ADDR 0x68  

 

// ---------- Control constants ----------  

#define BASE_PWM        100  

#define MIN_PWM_TURN     20  

#define KP_LINE         50.0  

#define KD_LINE         18.0  

#define KP_GYRO          0.05  

#define KP_SYNC          0.6  

#define MAX_PWM         255  

#define LEFT_OVERSHOOT    2.5     // Left motor runs slightly faster 

 

// ---------- Globals ----------  

float rpmLeft=0, rpmRight=0;  

volatile unsigned long lastLeft=0, periodLeft=0;  

volatile unsigned long lastRight=0, periodRight=0;  

float gyroZ=0, offsetZ=0;  

bool running=false;  

bool finished=false;  

int lastError=0;  

unsigned long startTime=0;  

float lapTime=0;  

int stopHits=0;  

 

// ---------- Encoder interrupts ----------  

void IRAM_ATTR handleLeftA() {  

  unsigned long now=micros();  

  if(lastLeft>0) periodLeft=now-lastLeft;  

  lastLeft=now;  

}  

void IRAM_ATTR handleRightA() {  

  unsigned long now=micros();  

  if(lastRight>0) periodRight=now-lastRight;  

  lastRight=now;  

}  

 

// ---------- Setup ----------  

void setup(){  

  Serial.begin(115200);  

  Wire.begin(SDA_PIN, SCL_PIN);  

  u8g2.begin();  

 

  pinMode(AIN1,OUTPUT); pinMode(AIN2,OUTPUT); pinMode(PWMA,OUTPUT);  

  pinMode(BIN1,OUTPUT); pinMode(BIN2,OUTPUT); pinMode(PWMB,OUTPUT);  

  pinMode(STBY,OUTPUT); digitalWrite(STBY,HIGH);  

 

  pinMode(ENC_A_LEFT,INPUT); pinMode(ENC_B_LEFT,INPUT);  

  pinMode(ENC_A_RIGHT,INPUT); pinMode(ENC_B_RIGHT,INPUT);  

  attachInterrupt(digitalPinToInterrupt(ENC_A_LEFT),handleLeftA,RISING);  

  attachInterrupt(digitalPinToInterrupt(ENC_A_RIGHT),handleRightA,RISING);  

 

  pinMode(S_FL,INPUT); pinMode(S_ML,INPUT);  

  pinMode(S_MR,INPUT); pinMode(S_FR,INPUT);  

  pinMode(BTN_PIN,INPUT_PULLUP);  

 

  // Wake MPU  

  Wire.beginTransmission(MPU_ADDR);  

  Wire.write(0x6B);  

  Wire.write(0);  

  Wire.endTransmission(true);  

 

  long sumZ=0;  

  for(int i=0;i<500;i++){  

    sumZ+=readGyroZRaw();  

    delay(3);  

  }  

  offsetZ=sumZ/500.0;  

 

  showIdleScreen();  

}  

 

// ---------- Main Loop ----------  

void loop(){  

  static bool btnLast=HIGH;  

  bool btn=digitalRead(BTN_PIN);  

 

  // toggle start/stop/reset  

  if(btnLast==HIGH && btn==LOW){  

    if(!running && !finished){  

      countdown();  

      running=true;  

      showMessage("RUN");  

      startTime=millis();  

      stopHits=0;  

    }  

    else if(running){  

      running=false;  

      drive(0,0);  

      showIdleScreen();  

    }  

    else if(finished){  

      finished=false;  

      stopHits=0;  

      lapTime=0;  

      showIdleScreen();  

    }  

  }  

  btnLast=btn;  

 

  if(periodLeft>0)  rpmLeft =(1e6/periodLeft)*60.0/(14*20.4);  

  if(periodRight>0) rpmRight=(1e6/periodRight)*60.0/(14*20.4);  

  gyroZ = -((readGyroZRaw()-offsetZ)/131.0);  

 

  // --- read sensors (FAST SAMPLE) ---  

  int fl = digitalRead(S_FL);  

  int ml = digitalRead(S_ML);  

  int mr = digitalRead(S_MR);  

  int fr = digitalRead(S_FR);  

  delayMicroseconds(1000);  // ~1 ms sampling delay for higher refresh rate 

 

  if(!running){  

    if(!finished) showIdleScreen();  

    return;  

  }  

 

  // --- STOP LOGIC (stop on third 1000 detection) ---  

  static unsigned long lastStopSeen = 0;  

  if(fl==1 && ml==0 && mr==0 && fr==0){  // 1000 pattern (FL sees ground, others see line) 

    unsigned long now = millis();  

    if(now - lastStopSeen > 150){  // debounce 

      stopHits++;  

      lastStopSeen = now;  

    }  

    if(stopHits >= 3){  

      running = false;  

      finished = true;  

      drive(0,0);  

      lapTime = (millis() - startTime) / 1000.0;  

      showLapTime(lapTime);  

      return;  

    }  

  }  

 

  // --- 3-sensor centered follow ---  

  if(fl && ml && mr){  

    drive(BASE_PWM + LEFT_OVERSHOOT, BASE_PWM);  

    drawCoolCar();  

    return;  

  }  

 

  // --- normal black-line tracking ---  

  int posError = (fl * -4) + (ml * 0) + (mr * 4);  

  int dError = posError - lastError;  

  lastError = posError;  

 

  int correction = (int)(1.1 * (KP_LINE * posError + KD_LINE * dError + KP_GYRO * gyroZ));  

  correction = constrain(correction, -BASE_PWM, BASE_PWM);  

 

  float syncError = rpmRight - rpmLeft;  

  int syncCorrection = (int)(KP_SYNC * syncError);  

 

  float turnSeverity = fabsf((float)posError) / 4.0;  

  turnSeverity = constrain(turnSeverity, 0.0, 1.0);  

  int turnPWM = BASE_PWM - (turnSeverity * (BASE_PWM - MIN_PWM_TURN));  

 

  int leftPWM  = turnPWM - correction - syncCorrection + LEFT_OVERSHOOT;  

  int rightPWM = turnPWM + correction + syncCorrection;  

 

  leftPWM  = constrain(leftPWM,  MIN_PWM_TURN, BASE_PWM + LEFT_OVERSHOOT);  

  rightPWM = constrain(rightPWM, MIN_PWM_TURN, BASE_PWM);  

 

  drive(leftPWM,rightPWM);  

  drawCoolCar();  

}  

 

// ---------- Drive ----------  

void drive(int pwmL,int pwmR){  

  pwmL = constrain(pwmL, -255, 255);  

  pwmR = constrain(pwmR, -255, 255);  

 

  if(pwmL>=0){  

    digitalWrite(AIN1,HIGH);  

    digitalWrite(AIN2,LOW);  

    analogWrite(PWMA,pwmL);  

  }  

  else {  

    digitalWrite(AIN1,LOW);   

    digitalWrite(AIN2,HIGH);  

    analogWrite(PWMA,-pwmL);  

  }  

 

  if(pwmR>=0){  

    digitalWrite(BIN1,LOW);   

    digitalWrite(BIN2,HIGH);  

    analogWrite(PWMB,pwmR);  

  }  

  else {  

    digitalWrite(BIN1,HIGH);  

    digitalWrite(BIN2,LOW);   

    analogWrite(PWMB,-pwmR);  

  }  

}  

 

// ---------- Helpers ----------  

int16_t readGyroZRaw(){  

  Wire.beginTransmission(MPU_ADDR);  

  Wire.write(0x47);  

  Wire.endTransmission(false);  

  Wire.requestFrom(MPU_ADDR,2,true);  

  return (Wire.read()<<8)|Wire.read();  

}  

 

// ---------- OLED ----------  

void showMessage(const char* msg){  

  u8g2.clearBuffer();  

  u8g2.setFont(u8g2_font_ncenB08_tr);  

  u8g2.drawStr(5,35,msg);  

  u8g2.sendBuffer();  

}  

 

void showLapTime(float t){  

  u8g2.clearBuffer();  

  u8g2.setFont(u8g2_font_ncenB10_tr);  

  u8g2.setCursor(15,28);  

  u8g2.print("FINISHED!");  

  u8g2.setCursor(15,50);  

  u8g2.print("Time: ");  

  u8g2.print(t,2);  

  u8g2.print(" s");  

  u8g2.sendBuffer();  

}  

 

void showIdleScreen(){  

  u8g2.clearBuffer();  

  u8g2.setFont(u8g2_font_ncenB08_tr);  

  u8g2.setCursor(5,35);  

  u8g2.print("PRESS START BUTTON");  

  u8g2.sendBuffer();  

}  

 

void countdown(){  

  for(int i=3;i>0;i--){  

    u8g2.clearBuffer();  

    u8g2.setFont(u8g2_font_fub30_tr);  

    u8g2.setCursor(60,45);  

    u8g2.print(i);  

    u8g2.sendBuffer();  

    delay(800);  

  }  

  showMessage("GO!");  

  delay(400);  

}  

 

// ---------- Cool Car Animation ----------  

void drawCoolCar(){  

  static int carX = 0;  

  static int exhaustToggle = 0;  

 

  carX += 5;  

  if(carX > 140) carX = -30;  

  exhaustToggle = !exhaustToggle;  

 

  u8g2.clearBuffer();  

  u8g2.drawHLine(0, 56, 128);  

  u8g2.drawBox(carX, 42, 28, 10);  

  u8g2.drawBox(carX + 20, 38, 8, 4);  

  u8g2.drawBox(carX + 8, 36, 10, 6);  

  u8g2.drawDisc(carX + 5, 56, 2, U8G2_DRAW_ALL);  

  u8g2.drawDisc(carX + 22, 56, 2, U8G2_DRAW_ALL);  

  if(exhaustToggle) u8g2.drawDisc(carX - 2, 46, 2, U8G2_DRAW_ALL);  

  u8g2.drawVLine(carX + 30, 44, 8);  

  u8g2.drawVLine(carX + 33, 46, 6);  

  u8g2.sendBuffer();  

}  

 

 
